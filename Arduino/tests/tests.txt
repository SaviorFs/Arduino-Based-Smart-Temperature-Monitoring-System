WiFi Connectivity Test
The Arduino code is designed to connect to a WiFi network using the WiFiS3 library. The connection logic is implemented inside the setup() function using a while (WiFi.begin(...) != WL_CONNECTED) loop. This ensures that the board continuously attempts to connect until successful. The Serial Monitor prints feedback during the connection process, including a final "WiFi Connected!" message to confirm success. This behavior was verified by uploading the code and observing the connection sequence and confirmation message via Serial Monitor.

WebSocket Communication Test
WebSocket communication is handled using the WebSocketsClient library. The connectToWebSocket() function initializes the connection to the WebSocket server hosted at realtimetempmonitor.com on port 8443. The connection is monitored in the loop() function using client.isConnected(), and automatic reconnection attempts are made every 5 seconds using millis()-based timing. The Serial Monitor displays "WebSocket Connected" when the connection is established and prints a "Sent: ..." message each time temperature data is transmitted. This confirms that the Arduino is actively pushing data through the WebSocket.

DHT11 Sensor Accuracy Test (Multi-Sensor Validation)
Temperature readings are obtained from a DHT11 sensor using the DHT library. The sensor is initialized in setup() with dht.begin(), and values are read in the loop() using dht.readTemperature(). To confirm the accuracy and consistency of readings, three different DHT11 sensors were individually tested under the same environmental conditions. Each sensor was connected, allowed to stabilize, and tested with the same code to verify that temperature readings were within ±0.4°C of each other. The use of isnan(temp) in the code ensures that only valid sensor readings are processed and transmitted.

LED Threshold Logic Test (Live and Simulated Inputs)
LED logic is managed by the updateLEDs(float temp) function, which takes the current temperature and compares it against the cold and hot thresholds defined at the top of the sketch. If the temperature is below or equal to the cold threshold, only the blue LED is activated. If the temperature falls between the cold and hot thresholds, the green LED turns on. If the temperature exceeds the hot threshold, the red LED is turned on. This function ensures that only one LED is active at a time and also logs the current state to the Serial Monitor. LED behavior was tested both with live temperature data and by temporarily inserting hardcoded temperature values into the loop to simulate different threshold conditions. LED status was confirmed through visual inspection and serial output.

Live Threshold Update Test via WebSocket
Threshold values for cold and hot ranges can be dynamically updated from the frontend dashboard using WebSocket messages. These updates are handled in the webSocketEvent() function, which parses incoming JSON using the ArduinoJson library. When new threshold values are received, the code updates the internal coldThreshold and hotThreshold variables and immediately re-evaluates the LED state using a fresh temperature reading. The code explicitly checks for valid keys in the payload using doc.containsKey(...) and confirms updates with Serial Monitor output such as "Cold Threshold Updated: ..." or "Hot Threshold Updated: ...". These updates were tested by submitting new threshold values from the dashboard UI and observing the immediate LED response.

Sensor Failure Handling Test
To ensure stability under sensor failure conditions, the code includes error handling for invalid temperature readings. When the DHT11 sensor fails or is disconnected, dht.readTemperature() returns NaN. This is checked using isnan(temp), and if true, the program prints "Failed to read temperature" to the Serial Monitor and skips both LED logic and WebSocket transmission. This prevents the system from sending bad data or displaying misleading LED states. This behavior was tested by physically disconnecting the sensor's data wire while the board was running and observing the correct error output and safe handling.